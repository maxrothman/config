# Git per-user config file

# Username and email are set by environment variables in ~/.bash-secure

[core]
  #only set this true if you're on windows
  ignorecase = false

  #Put hooks in this directory and they'll be accessible from all repos. MAKE SURE THEY'RE ALL EXECUTABLE!
  hooksPath = ~/repos/.git-hooks

[fetch]
  #WARNING: will remove local branches if they've been deleted from the remote
  prune = true

[diff]
  # Use the "patience" diff algorithm. It's better. Google it.
  algorithm = patience

# Visually highlight changes inside lines
[pager]
  log = /usr/local/share/git-core/contrib/diff-highlight/diff-highlight | less
  show = /usr/local/share/git-core/contrib/diff-highlight/diff-highlight | less
  diff = /usr/local/share/git-core/contrib/diff-highlight/diff-highlight | less
  branch = cat
[interactive]
  diffFilter = /usr/local/share/git-core/contrib/diff-highlight/diff-highlight

#For explanation on the following group of options, see <http://grimoire.ca/git/config>
[rebase]
  autosquash = true
[branch]
  autosetupmerge = always
  autosetuprebase = always
[push]
  default = simple
[rerere]
  enabled = true

#See <https://github.com/alebedev/git-media>
[filter "media"]
  clean = git media clean %f
  smudge = git media smudge %f
  required = true

[alias]
  s = status
  ch = checkout

  cm = commit -m
  cma = commit -a
  cmal = commit -a -m

  #Amend and don't change commit message. If file arguments are provided, amend only those files.
  #Usage: cmend [FILE ...]
  cmend = "!f() { cd \"$GIT_PREFIX\"; [ $# -eq 0 ] && all=-a || git add $@; git commit $all --amend --no-edit; }; f"
  #                   ^            ^
  #NB: without these quotes this'll run an empty cd when you're at the top of the repo taking you to ~
  
  #Add all the arguments and commit
  cmad = "!f() { cd \"$GIT_PREFIX\"; git add $@ && git commit; }; f"

  #Delete branch from remote
  delbranch = push origin --delete

  #Find all conflicts (not conflicted files) to avoid accidentally commiting half-resolved merges
  conflicts = !grep -H -r '>>>>>\\|<<<<<' --exclude-dir=.git

  #Push current local branch to the remote
  pushb = !git push --set-upstream origin $(git symbolic-ref --short HEAD)

  #safer push -f
  fpush = push --force-with-lease

  #Git diff showing additions/deletions/modifications
  changed = !git --no-pager diff --name-status

  #Show additions/deletions/modifications in git log
  logs = log --name-status
  
  #Pretty git log with graph and colors
  lg = log --graph --format=format:'%C(red)%h%C(reset) - %C(green)(%ar)%C(reset) %C(bold blue)%an%C(reset)%C(yellow)%d%C(reset)%n          %s'

  #Short-format log of all commits since the last merge
  lastlog = "!git --no-pager log --oneline $(git --no-pager log --merges -n1 --format='%H').."

  #Short-format log of all commits since the last push
  plastlog = "!git --no-pager log --oneline @{u}.."
 
  #Put all unpushed work on a new branch and reset this one
  #Usage: git switch <branchname>
  switch = "!f() { [ `git rev-list @{u}.. | wc -l` = 0 ] && return; [ -z $1 ] && echo branch name required && return 2; git branch $1 && if [ -n \"$(git status --porcelain)\" ]; then git stash --all && stashed=1; fi && git reset --hard @{u} && git checkout $1 && if [ -n \"$stashed\" ]; then  git stash pop; fi; }; f"
  
  #Open a pull request in github:
  # git pr: open a PR from the current branch against main-branch (defined below)
  # git pr <refname>: open a pr from the current branch against refname
  # git pr <ref1> <ref2>: open a pr from ref2 against ref1
  #All refnames are from the remote's perspective, so "git pr master HEAD^" will use origin's head, aka the tip of master.  
  pr = "!f() { open https://github.com/$(git config --get remote.origin.url | sed -r 's|^.*[:/]([^/]+/[^/]+).git$|\\1|')/compare/${1-$(git config --get myconfig.main-branch)}...${2-$(git symbolic-ref HEAD &> /dev/null && git rev-parse --abbrev-ref HEAD)}?expand=1; }; f"

  #Check out a github PR locally
  #Usage: git chpr <PR #>
  #Remember to delete the branch afterwards so you stop tracking it
  chpr = "!f() { git fetch origin pull/$1/head:pr-$1; git checkout pr-$1; }; f"
  
  #Show whether ref1 is merged into ref2 (default: HEAD) 
  #Usage: git merged <ref1> [ref2]
  merged = "!f() { git merge-base --is-ancestor $1 ${2-HEAD} && echo \"$1 is merged into ${2-HEAD}\" && return 0 || echo \"$1 is NOT merged into ${2-HEAD}\" && return 1; }; f"
  
  #Delete all local branches that have been merged into main-branch (as determined by the "git merged" alias)
  cleanup-merged = "!git for-each-ref --format '%(refname)' refs/heads | grep -vE $(git config --get myconfig.protected-branches) | while read ref; do git merged $ref $(git config --get myconfig.main-branch) >/dev/null && git branch -D ${ref#refs/heads/}; done"

  #Delete all local branches whose upstreams no longer exist (excluding branches that never had upstreams)
  cleanup-deleted = "!git for-each-ref refs/heads --format='%(refname:short) %(upstream:short)' | while read l; do remote=$(cut -d' ' -f2 <<< $l); here=$(cut -d' ' -f1 <<< $l); if [ -n \"$remote\" ]; then git rev-parse \"$remote\" &>/dev/null; result=$?; [ \"$result\" -gt 0 ] && git branch -D $here; fi; done"

  cleanup = "!git cleanup-merged; git cleanup-deleted"
  
  postmerge = !git checkout $(git config --get myconfig.main-branch) && git pull && git cleanup

# Custom config for aliases
[myconfig]
  #Default branch for several aliases, like pr and postmerge
  main-branch = master

  #"|"-separated list of branches that should not be cleaned up by cleanup-merged.
  #NB: to write a literal |, it will have to be preceeded by 2 backslashes, like \\|
  protected-branches = master

[user]
  email = max.r.rothman@gmail.com
  name = Max Rothman

